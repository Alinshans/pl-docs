# C++ 设计缺陷

Created @ 2014-08-01 21:46 rev2 2014-08-01 22:14, rev3 2015-09-15, markdown @ 2015-09-15.

## 0 兼容（而不是取代）C 。

## 1 设计上烂得最广泛的毫无疑问是类型系统——包括很多本来该在类型系统内的东西。

### 1.1 基本类型在 C 的基础上重写了一遍，有微妙的不同，但换汤不换药，缺点差不多一个没少。

### 1.2 继承了 C 的低质量的转换：

* integer promotion
* array-to-pointer conversion
* function-to-pointer conversion

### 1.3 继承了 C 对数组和函数类型的差别待遇。

### 1.4 添加了动态类型，却支持有限，实际上搞出了 ABI 的坑。

### 1.5 添加了和 C 不一样的布局，却不提供足够的、明确的、可移植的支持，导致基础设施的失效。

* 如 `offsetof` 

### 1.6 添加了引用类型，想取代 lvalueness （参见 WG21 最早公开的 paper ），后来却坑了。

* 现在还越搞越复杂，搞出了多种引用类型和 value category ，依然不视为类型
* 并且语义和用例容易被误解，且很多时候难以避免冗余编码

### 1.7 添加了参数化多态，却对高阶参数化类型（模板模板参数）有莫名其妙的限制导致不可用。

### 1.8 添加了实质上的参数化类型，却独立于名义上的类型系统之外。

### 1.9 添加了类型推导，却不足够支持一般意义的类型推断（例如构造函数）。

### 1.10 添加了实质上的重写系统却没有完善的类型系统支持（如基于类型的模式匹配；重载太弱）。

## 2 一些深刻的设计失误是差不多所有Algol60直系后裔都存在的功能缺失：

### 2.1 同像性。

这导致语言中不得不对反射做出特别对待。偏偏C艹到现在还没有。

### 2.2 底层高级流程抽象。

具体点说，能代替 J operator 或者 `call/cc` 之类的东西。

这导致诸如 coroutine 不能被可移植地高效实现。

### 2.3 活动记录抽象。

这导致典型实现及其用户过于依赖特定于体系结构的运行时栈。

实际上还同时有栈溢出 UB 这种无解的设定。

## 3 一些本不适合内建的特性相关问题。

内建特性在兼容性和扩展性上尤其容易出现问题，特别是存在不够显然的实现的时候。

### 3.1 异常不得不被实现为内建的，某种意义上是缺乏上述两者的直接结果——这导致了另外的问题：

* 例如ABI兼容性
* 再如 [WG21/N4049](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4049.pdf)

### 3.2 面向对象支持——关键是面向对象本身就没有个相对统一的认识。

* 内建导致之后扩充多分派等需要顾及的太多而最终放弃，远不如 CLOS 之类的库解决方案灵活
* 同样在一些方面导致和加重了ABI问题

### 4 阶段相关。

某种意义上是缺乏同像性的副作用。

实现阶段数量过多，且过于琐碎，导致细节难以处理，也难以提高实现质量。

### 4.1 预处理被标准化，但是细节比较混乱，导致了很多演进上的问题。

* 像 `#ifdef` 和 `#if defined` 的冗余

### 4.2 缺少可用的模块系统。

### 4.3 存在语言链接支持却缺乏可移植的语言嵌入。

只有一个 `asm` 还不指望能用。

### 5 至于文法/语法嘛……

本来懒得说，不过因为逗到一定境界也顺便提一下好了。

### 5.1 兼容C的渣声明符中缀语法。

特别地， C++11 引入 `trailing-return-type` 后也没法放弃旧的语法，并存的结果是增加复杂性。

### 5.2 比C更多的文法歧义。

最著名的坑应该就是函数声明优先于初始化对象了。另外还有几个类似的地方。

### 5.3 标点问题。

因为基本源字符集的限制，使用大于(`<`) 和小于(`>`) 的尖括号(angle brackets) 代替了数学上习惯的看起来更扁一点的括号(chevrons) “〈”和“〉”。这导致了极大的解析上的复杂性，同时还需要增设特例规则（记号 `>>` 和记号序列 `> >` 歧义）。

### 5.4 少数C的语法的不规则延伸。

如 `new` 。

除了单独的消歧义规则的复杂性外，特异的语法规则导致用宏替换实现一些操作更困难。

